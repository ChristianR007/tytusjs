class NodeTree{constructor(t=null,i="",e=[]){this.id=Math.random().toString(15).substr(3,12),this.tag=i,this.value=t,this.childs=e}}class Feature{constructor(t,i,e){this.attribute=t,this.entropy=-1,this.gain=-1,this.primaryCount=0,this.secondaryCount=0,this.primaryPosibility=i,this.secondPosibility=e}updateFeature(t){if(t===this.primaryPosibility)this.primaryCount+=1;else{if(t!==this.secondPosibility)return!1;this.secondaryCount+=1}return this.entropy=this.calculateEntropy(this.primaryCount,this.secondaryCount),!0}calculateEntropy(t,i){let e=-1;return 0==t||0==i?0:(e=-t/(t+i)*Math.log2(t/(t+i)),e+=-i/(t+i)*Math.log2(i/(t+i)))}}class Attribute{constructor(t){this.attribute=t,this.features=[],this.infoEntropy=-1,this.gain=-1,this.index=-1}}class DecisionTreeID3{constructor(t=[]){this.dataset=t,this.generalEntropy=-1,this.primaryCount=-1,this.secondaryCount=-1,this.primaryPosibility="",this.secondPosibility="",this.root=null}calculateEntropy(t,i){let e=-1;return 0==t||0==i?0:(e=-t/(t+i)*Math.log2(t/(t+i)),e+=-i/(t+i)*Math.log2(i/(t+i)))}train(t,i=0){let e=t[0].length-1;this.calculateGeneralEntropy(t,e);let s=t[0].length,n=[];for(let r=i;r<s;r++){if(r===e)continue;let i=new Attribute(t[0][r]);i.index=r,i.features=this.classifierFeatures(t,r,e),i.infoEntropy=this.calculateInformationEntropy(i.features),i.gain=this.calculateGain(this.generalEntropy,i.infoEntropy),n.push(i)}if(0==n.length)return null;let r=this.selectBestFeature(n),a=new NodeTree(n[r].attribute);return n[r].features.map(e=>{let s=new NodeTree(null);if(0==e.entropy)s.value=0==e.primaryCount?e.secondPosibility:e.primaryPosibility;else{let a=t.filter((t,i)=>t[n[r].index]===e.attribute||0==i);i<4&&a.length>2&&(s=this.train(a,i+1))}s.tag=e.attribute,a.childs.push(s)}),a}predict(t,i){return this.recursivePredict(t,i)}recursivePredict(t,i){if(0==i.childs.length)return i;for(let e=0;e<t[0].length;e++)if(t[0][e]===i.value)for(let s=0;s<i.childs.length;s++)if(i.childs[s].tag===t[1][e])return this.recursivePredict(t,i.childs[s]);return null}calculateGeneralEntropy(t,i){let e={tag:"",count:0},s={tag:"",count:0},n=!1;return t.map(t=>{n?e.tag?s.tag||t[i]==e.tag?e.tag===t[i]?e.count+=1:s.tag===t[i]&&(s.count+=1):(s.tag=t[i],s.count+=1):(e.tag=t[i],e.count+=1):n=!0}),this.primaryPosibility=e.tag,this.secondPosibility=s.tag,this.primaryCount=e.count,this.secondaryCount=s.count,this.generalEntropy=this.calculateEntropy(e.count,s.count),this.generalEntropy}classifierFeatures(t,i,e){let s=[],n=!1;return t.map(t=>{if(n){let n=s.findIndex(e=>e.attribute===t[i]);if(n>-1)s[n].updateFeature(t[e]);else{let n=new Feature(t[i],this.primaryPosibility,this.secondPosibility);n.updateFeature(t[e]),s.push(n)}}else n=!0}),s}calculateInformationEntropy(t){let i=0;return t.map(t=>{i+=(t.primaryCount+t.secondaryCount)/(this.primaryCount+this.secondaryCount)*t.entropy}),i}calculateGain(t,i){return t-i}selectBestFeature(t){let i=-1,e=-1e3;return t.map((t,s)=>{t.gain>e&&(e=t.gain,i=s)}),i}generateDotString(t){let i="{";return i+=this.recursiveDotString(t),i+="}"}recursiveDotString(t,i=""){let e="";return t?(e+=`${t.id} [label="${t.value}"];`,e+=i?`${i}--${t.id}`:"",e+=t.tag?`[label="${t.tag}"];`:"",t.childs.map(i=>{e+=this.recursiveDotString(i,t.id)}),e):""}}class PolynomialModel{constructor(){this.isFit=!1}}class PolynomialRegression extends PolynomialModel{constructor(){super(),this.solutions=[],this.error=0}fit(t,i,e){let s=e+1,n=e+2,r=new Array(s);for(let t=0;t<s;t++)r[t]=new Array(n);for(let e=0;e<s;e++)for(let s=0;s<n;s++){let a=0;if(0==e&&0==s)a=t.length;else if(s==n-1)for(let s=0;s<t.length;s++)a+=Math.pow(t[s],e)*i[s];else for(let i=0;i<t.length;i++)a+=Math.pow(t[i],s+e);r[e][s]=a}for(let t=1;t<s;t++)for(let i=0;i<=t-1;i++){let e=r[t][i]/r[i][i];for(let s=i;s<n;s++)r[t][s]=r[t][s]-e*r[i][s]}for(let t=s-1;t>-1;t--)for(let i=s-1;i>-1;i--)t==i?r[t][n-1]=r[t][n-1]/r[t][i]:0!=r[t][i]&&(r[t][n-1]-=r[t][i]*r[i][n-1]);this.solutions=new Array(s);for(let t=0;t<s;t++)this.solutions[t]=r[t][n-1];this.isFit=!0,this.calculateR2(t,i)}predict(t){let i=[];if(this.isFit)for(let e=0;e<t.length;e++){let s=0;for(let i=0;i<this.solutions.length;i++)s+=this.solutions[i]*Math.pow(t[e],i);i.push(s)}return i}calculateR2(t,i){let e=new Array(t.length),s=this.predict(t),n=0;for(let r=0;r<t.length;r++)n+=i[r],e[r]=Math.pow(i[r]-s[r],2);let r=0,a=0;for(let s=0;s<t.length;s++)r+=e[s],a+=Math.pow(i[s]-n/t.length,2);let l=(a-r)/a;this.error=l}getError(){return this.error}}class LinearModel{constructor(){this.isFit=!1}}class LinearRegression extends LinearModel{constructor(){super(),this.m=0,this.b=0}fit(t,i){for(var e=0,s=0,n=0,r=0,a=0;a<t.length;a++)e+=t[a],s+=i[a],n+=t[a]*i[a],r+=t[a]*t[a];this.m=(t.length*n-e*s)/(t.length*r-Math.pow(Math.abs(e),2)),this.b=(s*r-e*n)/(t.length*r-Math.pow(Math.abs(e),2)),this.isFit=!0}predict(t){var i=[];if(this.isFit)for(var e=0;e<t.length;e++)i.push(this.m*t[e]+this.b);return i}mserror(t,i){for(var e=0,s=0;s<t.length;s++)e+=Math.pow(t[s]-i[s],2);return e/t.length}}class KNearestNeighbor{constructor(t=[]){this.individuals=t}euclidean(t){var i=[],e=this.individuals[0].length-1;for(const n of this.individuals){var s=n.slice(0,e);i.push(euclidean(t,s))}let n=Math.min(...i),r=[];for(const t in i)i[t]==n&&r.push(this.individuals[t][e]);return[...new Set(r)]}manhattan(t){var i=[],e=this.individuals[0].length-1;for(const n of this.individuals){var s=n.slice(0,e);i.push(manhattan(t,s))}let n=Math.min(...i),r=[];for(const t in i)i[t]==n&&r.push(this.individuals[t][e]);return[...new Set(r)]}}class FuzzySet{constructor(t=[]){this.individuals=t,this.minsAndMaxs=this.calculateMinsAndMax()}calculateMinsAndMax(){var t=[[],[],[]],i=this.individuals[0].length-1;for(let e=0;e<this.individuals.length;e++)for(let s=0;s<i;s++)null==t[s][0]?t[s][0]=this.individuals[e][s]:t[s][0]=Math.min(t[s][0],this.individuals[e][s]),null==t[s][1]?t[s][1]=this.individuals[e][s]:t[s][1]=Math.max(t[s][1],this.individuals[e][s]);return t}normalization(){var t=[],i=this.individuals[0].length-1;for(let e=0;e<this.individuals.length;e++){let s=[];for(let t=0;t<i;t++)this.individuals[e][t]<=this.minsAndMaxs[t][0]?s.push(0):this.individuals[e][t]>=this.minsAndMaxs[t][1]?s.push(1):s.push(((this.individuals[e][t]-this.minsAndMaxs[t][0])/(this.minsAndMaxs[t][1]-this.minsAndMaxs[t][0])).toFixed(5));t.push(s)}return t}euclidean(t){var i=this.individuals[0].length-1,e=this.normalization(),s=[];for(let i=0;i<t.length;i++)t[i]<=this.minsAndMaxs[i][0]?s.push(0):t[i]>=this.minsAndMaxs[i][1]?s.push(1):s.push(((t[i]-this.minsAndMaxs[i][0])/(this.minsAndMaxs[i][1]-this.minsAndMaxs[i][0])).toFixed(5));var n=[];for(const t of e){var r=t.slice(0,i);n.push(euclidean(s,r))}let a=Math.min(...n),l=[];for(const t in n)n[t]==a&&l.push(this.individuals[t][i]);return[...new Set(l)]}manhattan(t){var i=this.individuals[0].length-1,e=this.normalization(),s=[];for(let i=0;i<t.length;i++)t[i]<=this.minsAndMaxs[i][0]?s.push(0):t[i]>=this.minsAndMaxs[i][1]?s.push(1):s.push(((t[i]-this.minsAndMaxs[i][0])/(this.minsAndMaxs[i][1]-this.minsAndMaxs[i][0])).toFixed(5));var n=[];for(const t of e){var r=t.slice(0,i);n.push(manhattan(s,r))}let a=Math.min(...n),l=[];for(const t in n)n[t]==a&&l.push(this.individuals[t][i]);return[...new Set(l)]}}class KMeans{constructor(){this.k=3}}class LinearKMeans extends KMeans{constructor(){super(),this.data=[]}clusterize(t,i,e){let s=[];this.data=i;for(let n=0;n<e;n++){let e=[];for(let s=0;s<t;s++){let t=i[Math.floor(Math.random()*i.length)];for(;-1!=e.findIndex(i=>i===t);)t=i[Math.floor(Math.random()*i.length)];e.push(t)}e=e.sort(function(t,i){return t>i?1:i>t?-1:0});let n=[],r=[],a=0,l=0,h=!0;i.forEach(t=>{a=0,l=0,h=!0,e.forEach(i=>{let e=this.distance(t,i);h?(l=Math.abs(e),a=i,h=!h):Math.abs(e)<l&&(l=Math.abs(e),a=i),n.push([t,i,e])}),r.push([t,a,l])});let o=[],u=0,c=[];do{o=c,c=[],u=0,e.forEach((t,i)=>{let s=r.filter(i=>i[1]==t).map(t=>t[0]);c.push(this.calculateMeanVariance(s)),u+=s[1],e[i]=c[i][0]}),Number.isNaN(u)&&(u=0),n=[],r=[],a=0,l=0,h=!0,i.forEach(t=>{a=0,l=0,h=!0,e.forEach(i=>{let e=this.distance(t,i);h?(l=Math.abs(e),a=i,h=!h):Math.abs(e)<l&&(l=Math.abs(e),a=i),n.push([t,i,e])}),r.push([t,a,l])})}while(JSON.stringify(o)!=JSON.stringify(c));s.push([u,e,r])}return s.sort(function(t,i){return t[0]>i[0]?1:i[0]>t[0]?-1:0}),s[0][2]}distance(t,i){return i-t}calculateMeanVariance(t){var i=t.reduce(function(t,i){return t+i}),e=function(t,i){return t.reduce(function(t,e){return t+=Math.pow(e-i,2)},0)}(t,i/t.length),s={mean:i/t.length,variance:e/t.length};return[s.mean,s.variance]}}function joinArrays(){var t=[];if(6==arguments.length){t.push([arguments[0],arguments[2],arguments[4]]);for(var i=0;i<arguments[1].length;i++)t.push([arguments[1][i],arguments[3][i],arguments[5][i]])}return t}function zip(t){return t[0].map(function(i,e){return t.map(function(t){return t[e]})})}function euclidean(t,i){for(var e=0,s=0;s<t.length;s++)e+=Math.pow(t[s]-i[s],2);return Math.sqrt(e).toFixed(5)}function manhattan(t,i){for(var e=0,s=0;s<t.length;s++)e+=Math.abs(t[s]-i[s]);return e}